# PID 控制入门：从理论到电机调速实战

PID 是最经典的闭环控制算法，广泛用于温度控制、电机调速、平衡车等场景。本文记录我在 STM32 上实现直流电机 PID 速度控制的过程。

## PID 是什么

PID 由三个部分组成：

- **P（比例）**：误差越大，输出越大。响应快但会有稳态误差
- **I（积分）**：累计历史误差，消除稳态误差。但容易引起超调和振荡
- **D（微分）**：预测误差变化趋势，抑制超调。对噪声敏感

公式：

```
u(t) = Kp * e(t) + Ki * ∫e(t)dt + Kd * de(t)/dt
```

离散化后：

```c
output = Kp * error + Ki * error_sum + Kd * (error - last_error);
```

## 硬件准备

- STM32F103C8T6（Blue Pill）
- L298N 电机驱动模块
- 带编码器的直流减速电机
- 12V 电源

编码器通过 STM32 的定时器编码器模式读取，PWM 通过另一个定时器输出。

## 代码实现

### PID 结构体

```c
typedef struct {
    float Kp, Ki, Kd;
    float error;
    float last_error;
    float error_sum;
    float output;
    float output_max;
    float output_min;
} PID_TypeDef;
```

### PID 计算函数

```c
float PID_Compute(PID_TypeDef *pid, float target, float actual) {
    pid->error = target - actual;
    pid->error_sum += pid->error;

    // 积分限幅，防止 windup
    if (pid->error_sum > 1000) pid->error_sum = 1000;
    if (pid->error_sum < -1000) pid->error_sum = -1000;

    pid->output = pid->Kp * pid->error
                + pid->Ki * pid->error_sum
                + pid->Kd * (pid->error - pid->last_error);

    // 输出限幅
    if (pid->output > pid->output_max) pid->output = pid->output_max;
    if (pid->output < pid->output_min) pid->output = pid->output_min;

    pid->last_error = pid->error;
    return pid->output;
}
```

### 定时器中断中调用

```c
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM3) {  // 10ms 周期
        float speed = ReadEncoderSpeed();
        float pwm = PID_Compute(&speed_pid, target_speed, speed);
        SetMotorPWM(pwm);
    }
}
```

## 调参经验

调参顺序：**先 P，再 I，最后 D**。

1. Ki = 0, Kd = 0，逐步增大 Kp 直到系统快速响应但出现轻微振荡
2. Kp 回调一点，逐步增大 Ki 消除稳态误差
3. 如果超调严重，加入 Kd 抑制

我的最终参数：`Kp=2.5, Ki=0.08, Kd=0.3`，电机在 0.5 秒内稳定到目标转速。

## 常见问题

- **积分饱和（Windup）**：长时间误差累积导致输出饱和，必须做积分限幅
- **微分噪声**：编码器信号有抖动，D 项会放大噪声。可以对误差做低通滤波
- **采样周期**：PID 计算频率要稳定，用定时器中断而不是主循环

## 小结

PID 看起来简单，调起来需要耐心。理解每个参数的物理意义比盲目试参数更重要。下一步打算尝试位置闭环和串级 PID 控制。
